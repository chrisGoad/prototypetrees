// Copyright 2019 Chris Goad
// License: MIT

/* When a Object has a method called update, the state of that node is maintained by application of that method
 * when there are changes. Some nodes within the tree might be generated by update, and in that case, the node is marked computed.
 * Independently, the atomic values of some properties might be set by update, and in that case, the property might me marked computed.
 * Typically, the latter marking is made on the prototype (eg, if width of a bar is computed, this fact is declared in the prototype of the bar)
 */


const declareComputed = function (node) {
  node.__computed = 1; 
  return node;
}

//defineFieldAnnotation("computed");  // defines __setComputed and __getComputed

const isComputed = function (node,k,id) {
  let d = id?id:0;
  if (d > 20) {
     error('update','stack overflow'); 
  }
  if (!node) {
    return false;
  }
  if (node.__computed) {
    return true;
  }
  if (k && node.__getcomputed(k)) {
    return true;
  }
  
  return isComputed(node.__get('__parent'),undefined,d+1);
}


let updateCount = 0;
let catchUpdateErrors = false;// useful off for debugging;

let displayError;

const setDisplayError = function (fn) {
  displayError = fn;
}

const updateErrorHandler = function (node,e) {
  debugger; //keep
  let msg = e.message + ' in update';
  let src = node.__sourceUrl;
  if (src) {
    msg += ' from '+src;
  } else {
    let name = node.__name;
    if (name) {
      msg += ' of '+name;
    }
  }
  error(msg);
  if (displayError) {
    displayError(msg);
  }
}

let preUpdateHooks = [];

let updateFilter;

const setUpdateFilter = function (fn) {
  updateFilter = fn;
}

ObjectNode.__update = function () {
  if (!this.update) {
    return;
  }
  if (updateFilter  && !updateFilter(this)) {
    return;
  }
  preUpdateHooks.forEach((f) => {f(this)});
  log('update','__updating ',this.__name);
  if (catchUpdateErrors) {
    try {
      this.update.apply(this,arguments);     
    } catch(e) {
      updateErrorHandler(this,e);
      return;
    }
  } else {
    this.update.apply(this,arguments);
  }
  if (this.__updateCount) {
    this.__updateCount++;
  } else {
    this.__updateCount = 1;
  }
}
const forEachPart = function (node,fn,filter) {
  forEachTreeProperty(node,function (child) {
    if (child.update) {
      if (!filter || filter(child)) {
        fn(child);
      }
    } else {
      forEachPart(child,fn,filter);
    }
  });
}

ObjectNode.__updateAndDraw = function () {
  this.__update();
  this.draw();
}

const partsFromSource = function (src) {
  let rs = ArrayNode.mk();
  forEachPart(function () {
    if (fromSource(src)) {
      rs.push(src);
    }
  })
  return rs;
}

  


const updateParts = function (node,filter) {
  let updateLast = [];
  forEachPart(node,function (inode) {
    if (inode.__updateLast) {
      updateLast.push(inode);
    } else {
      inode.__update();
    }
  },filter);
  updateLast.forEach(function (inode) {
    inode.__update();
  });
}

const updateInheritors = function (node,filter) {
  forInheritors(node,function (x) {x.__update()},filter);
}


const resetArray = function (node,prop) {
  let child = node.__get(prop); 
  if (child) {
    removeChildren(child);
  } else {
    child = node.set(prop,ArrayNode.mk());
  }
  return child;
}




export {updateParts,isComputed,setUpdateFilter,setDisplayError,displayError};
//getData,setDataString,removeComputed,restoreComputed,resetComputedArray,resetComputedObject,declareComputed
