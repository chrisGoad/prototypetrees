// Copyright 2019 Chris Goad
// License: MIT

/* When a Object has a method called update, the state of that node is maintained by application of that method
 * when there are changes. Some nodes within the tree might be generated by update, and in that case, the node is marked computed.
 * Independently, the atomic values of some properties might be set by update, and in that case, the property might me marked computed.
 * Typically, the latter marking is made on the prototype (eg, if width of a bar is computed, this fact is declared in the prototype of the bar)
 */


const declareComputed = function (node) {
  node.__computed = 1; 
  return node;
}

defineFieldAnnotation("computed");  // defines __setComputed and __getComputed

const isComputed = function (node,k,id) {
  let d = id?id:0;
  if (d > 20) {
     error('update','stack overflow'); 
  }
  if (!node) {
    return false;
  }
  if (node.__computed) {
    return true;
  }
  if (k && node.__getcomputed(k)) {
    return true;
  }
  
  return isComputed(node.__get('__parent'),undefined,d+1);
}


let updateCount = 0;
let catchUpdateErrors = false;// useful off for debugging;

let displayError;

const setDisplayError = function (fn) {
  displayError = fn;
}

const updateErrorHandler = function (node,e) {
  debugger; //keep
  let msg = e.message + ' in update';
  let src = node.__sourceUrl;
  if (src) {
    msg += ' from '+src;
  } else {
    let name = node.__name;
    if (name) {
      msg += ' of '+name;
    }
  }
  error(msg);
  if (displayError) {
    displayError(msg);
  }
}

let preUpdateHooks = [];

let updateFilter;

const setUpdateFilter = function (fn) {
  updateFilter = fn;
}

ObjectNode.__update = function () {
  if (!this.update) {
    return;
  }
  if (updateFilter  && !updateFilter(this)) {
    return;
  }
  let inhs = inheritors(this);
  if (inhs.length > 1) {
    inhs.forEach((inh) => {
      if (inh !== this) {
        inh.__update();
      }
    });
    return;
  }
  preUpdateHooks.forEach((f) => {f(this)});
  log('update','__updating ',this.__name);
  if (catchUpdateErrors) {
    try {
      this.update.apply(this,arguments);     
    } catch(e) {
      updateErrorHandler(this,e);
      return;
    }
  } else {
    this.update.apply(this,arguments);
  }
  this.__newData = 0;
  if (this.__updateCount) {
    this.__updateCount++;
  } else {
    this.__updateCount = 1;
  }
}

ObjectNode.__initialize = function () {
  if (this.initialize) {
    this.initialize();
  }
}

const forEachPart = function (node,fn,filter) {
  forEachTreeProperty(node,function (child) {
    if (child.update) {
      if (!filter || filter(child)) {
        fn(child);
      }
    } else {
      forEachPart(child,fn,filter);
    }
  });
}

ObjectNode.__updateAndDraw = function () {
  this.__update();
  this.draw();
}

const partsFromSource = function (src) {
  let rs = ArrayNode.mk();
  forEachPart(function () {
    if (fromSource(src)) {
      rs.push(src);
    }
  })
  return rs;
}
const partAncestor = function (node) {
  let rs = node;
  while (1) {
    if (rs.update) {
      return rs;
    }
    let pr = rs.__get('__parent');
    if (pr) {
      rs = pr;
    } else {
      return rs;
    }
  }
}
  
  


const updateParts = function (node,filter) {
  let updateLast = [];
  forEachPart(node,function (inode) {
    if (inode.__updateLast) {
      updateLast.push(inode);
    } else {
      inode.__update();
    }
  },filter);
  updateLast.forEach(function (inode) {
    inode.__update();
  });
}

const updateInheritors = function (node,filter) {
  forInheritors(node,function (x) {x.__update()},filter);
}

const updateRoot = function (filter) {
  if (root && root.update && (!filter || filter(root)))  {
    root.__update();
  } else if (root) {
      updateParts(root,filter);
  }
}

const updateAncestors = function (node) {
  if (node) {
    node.__update();
    updateAncestors(node.__parent);
  }
}


const resetArray = function (node,prop) {
  let child = node.__get(prop); 
  if (child) {
    removeChildren(child);
  } else {
    child = node.set(prop,ArrayNode.mk());
  }
  return child;
}

const resetComputedArray = function (node,prop) {
  let child = resetArray(node,prop);
  declareComputed(child);
  return child;
}


// data might be internal, in which case the __internalData and __internalDataString are set, or external, in which case .data is a value with a __sourceUrl

const getData = function (node,idata) {
  if (idata) {
    if (getval(idata,'__sourceUrl')) {
      node.data = idata;
    } else {
      let data = core.lift(idata);
      if (data.__parent) {
        node.data = data;
      } else {
        node.set('data',data);
      }
    }
    return node.data;
  } 
  if (node.__internalData) {
    return node.__internalData;
  }
  if (node.data) {
    return node.data;
  }
  
  let indata = node.__internalDataString;
  if (indata) {
    let data = lift(JSON.parse(indata));
   // data.__computed = true;
    node.set("__internalData",data);
    return data;
  }
  
  
}

const setDataString = function (node,str) {
  node.__internalDataString = str;
  node.__internalData = undefined; // getData will now update __internalData from __internalDataString
}

ObjectNode.initializeData = function (dataString) {
   this.__internalDataString = dataString;
   this.__internalData = undefined;
   return getData(this);
}



// create a new fresh value for node[prop], all set for computing a new state

const resetComputedObject = function (node,prop,factory) {
  let value = node.__get(prop),
    newValue;
  if (value) {
    removeChildren(value);
  } else {
    if (factory) {
      newValue = factory();
    } else {
      newValue = ObjectNode.mk();
    }
    value = node.set(prop,newValue);
  }
  declareComputed(value);
  return value;
}
 
 //resetComputedDNode = pj.resetComputedObject; // old name
 
/* if stash is nonnull, save the computed nodes to stash
 * the stash option is used when saving an item, but wanting its state to persist after the save
 */

const removeComputed = function (node,stash) {
  let  found = 0;
  let computedProperties = node.__computedProperties;
  forEachTreeProperty(node,function (child,prop) {
    if (prop === "__required") {
      return;
    }
    let tp = typeof child;
    if (!child || (tp !== 'object')) {
      if (computedProperties && (tp === 'string') && computedProperties[prop]) {
        stash[prop] = child;
        node[prop] = '';
        return 1;
      }
      return 0;
    }
    if (child.__computed) {
      found = 1;
      if (stash) {
        stash[prop] = child;
      }
      if (ArrayNode.isPrototypeOf(child)) {
        node.set(prop,ArrayNode.mk());
      } else {
        child.remove();
      }
    } else {
      let stashChild;
      if (stash) {
        stashChild = stash[prop] = {__internalNode:1};
      } else {
        stashChild = undefined;
      }
      if (removeComputed(child,stashChild)) {
        found = 1;
      } else {
        if (stash) {
          delete stash[prop];
        }
      }
    }
  },true);
  return found;
}


const restoreComputed = function (node,stash) {
  for (let prop in stash) {
    if (prop === '__internalNode') {
      continue;
    }
    let stashChild = stash[prop];
    if (!stashChild) {
      return;
    }
    if (typeof stashChild === 'string') {
      node[prop] = stashChild;
      return;
    }
    if (stashChild.__internalNode) {
      restoreComputed(node[prop],stashChild);
    } else {
      node[prop] = stashChild;
    }
  }
}
  
export {updateRoot,updateParts,isComputed,setUpdateFilter,setDisplayError,displayError,getData,setDataString,
removeComputed,restoreComputed,resetComputedArray,resetComputedObject,declareComputed};
